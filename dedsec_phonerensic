#!/usr/bin/python3
import os
import subprocess
import sys
import time
from tabulate import tabulate

RESET = "\033[0m"
GREEN = "\033[92m"
RED = "\033[91m"
CYAN = "\033[96m"

green_dot = '[\033[92m●\033[0m]'
green_command = '[\033[92m+\033[0m]'
green_question = '[\033[92m?\033[0m]'
red_dot = '[\033[91m●\033[0m]'
red_warning = '[\033[91m!\033[0m]'

def banner():
    os.system('clear')
    banner = f'''



                            ░░░░░░░░░░░░░░░░░░░░░▄▀░░▌
                            ░░░░░░░░░░░░░░░░░░░▄▀▐░░░▌
                            ░░░░░░░░░░░░░░░░▄▀▀▒▐▒░░░▌
                            ░░░░░▄▀▀▄░░░▄▄▀▀▒▒▒▒▌▒▒░░▌
                            ░░░░▐▒░░░▀▄▀▒▒▒▒▒▒▒▒▒▒▒▒▒█
                            ░░░░▌▒░░░░▒▀▄▒▒▒▒▒▒▒▒▒▒▒▒▒▀▄
                            ░░░░▐▒░░░░░▒▒▒▒▒▒▒▒▒▌▒▐▒▒▒▒▒▀▄
                            ░░░░▌▀▄░░▒▒▒▒▒▒▒▒▐▒▒▒▌▒▌▒▄▄▒▒▐
                            ░░░▌▌▒▒▀▒▒▒▒▒▒▒▒▒▒▐▒▒▒▒▒█▄█▌▒▒▌
                            ░▄▀▒▐▒▒▒▒▒▒▒▒▒▒▒▄▀█▌▒▒▒▒▒▀▀▒▒▐░░░▄
                            ▀▒▒▒▒▌▒▒▒▒▒▒▒▄▒▐███▌▄▒▒▒▒▒▒▒▄▀▀▀▀
                            ▒▒▒▒▒▐▒▒▒▒▒▄▀▒▒▒▀▀▀▒▒▒▒▄█▀░░▒▌▀▀▄▄
                            ▒▒▒▒▒▒█▒▄▄▀▒▒▒▒▒▒▒▒▒▒▒░░▐▒▀▄▀▄░░░░▀
                            ▒▒▒▒▒▒▒█▒▒▒▒▒▒▒▒▒▄▒▒▒▒▄▀▒▒▒▌░░▀▄
                            ▒▒▒▒▒▒▒▒▀▄▒▒▒▒▒▒▒▒▀▀▀▀▒▒▒▄▀

                            {GREEN} P H O N E R E N S I C {RESET}
                                
                            DEDSEC ANDROID FORENSIC TOOL
                            Coded by: 0xbit
    '''
    print(banner)

ADB_COMMANDS = ({
    "Get Shell": "adb shell",
    "Get Device Model": "adb shell getprop ro.product.model",
    "Get Android Version": "adb shell getprop ro.build.version.release",
    "Get Device Manufacturer":"adb shell getprop ro.product.manufacturer",
    "Get Android Security Patch Level": "adb shell getprop ro.build.version.security_patch",
    "Get Device Bootloader Version": "adb shell getprop ro.bootloader",
    "Get Kernel Version": "adb shell uname -r",
    "Get Device Uptime": "adb shell uptime",
    "Get Current User": "adb shell whoami",
    "List System Users": "adb shell pm list users",
    "Get Screen Resolution": "adb shell wm size",
    "Get Screen Density": "adb shell wm density",
    "Check Internet Connectivity": "adb shell ping -c 4 8.8.8.8",
    "Show Active Network Connections": "adb shell netstat -tunapl",
    "Check DNS Configuration": "adb shell getprop net.dns1",
    "Get Wi-Fi Signal Strength": "adb shell dumpsys wifi | grep 'RSSI'",
    "Show Wi-Fi Networks": "adb shell iwlist wlan0 scan",
    "Flush DNS Cache": "adb shell ndc resolver flushif wlan0",
    "Restart Wi-Fi": "adb shell svc wifi disable && adb shell svc wifi enable",
    "Show Running Services": "adb shell service list",
    "Show App CPU Usage": "adb shell dumpsys cpuinfo",
    "Show Battery Health & Status": "adb shell dumpsys battery",
    "Show System Memory Usage": "adb shell cat /proc/meminfo",
    "Check GPU Usage": "adb shell dumpsys gfxinfo",
    "Show Temperature Sensors": "adb shell dumpsys thermalservice",
    "List USB Devices Connected": "adb shell lsusb",
    "List All Files in /sdcard": "adb shell ls -al /sdcard/",
    "List All Files in /system": "adb shell ls -al /system/",
    "List lastest modified files in /sdcard": "adb shell ls -lt /sdcard/ | grep -v '^d'",
    "Find Specific File": "adb shell find /sdcard/ -name",
    "Mount System as Read/Write (root)": "adb shell su -c 'mount -o rw,remount /system'",
    "Extract System Partition (root)": "adb pull /system ./system_dump/",
    "Copy a File": "adb shell cp /sdcard/file.txt /sdcard/backup.txt",
    "Upload a File": "adb push file.txt /sdcard/",
    "Download a File": "adb pull /sdcard/file.txt",
    "Delete a File": "adb shell rm /sdcard/file.txt",
    "Extract App Data (root)": "adb shell su -c 'cp -r /data/data/com.example.app /sdcard/'",
    "Get APK File of an Installed App": "",
    "Freeze an App (Disables it)": "",
    "Unfreeze an App (Re-enables it)": "",
    "Hide an App (root)": "",
    "Unhide Hidden Apps (root)": "",
    "Extract WhatsApp Messages (root)": "adb shell su -c 'cp /data/data/com.whatsapp/databases/msgstore.db /sdcard/'",
    "Extract Telegram Cache (root)": "adb shell su -c 'cp -r /data/data/org.telegram.messenger/cache /sdcard/'",
    "Extract All Saved Passwords (root)": "adb shell su -c 'cat /data/system/users/0/accounts_ce.db'",
    "List All Permissions of an App": "adb shell dumpsys package com.example.app | grep permission",
    "List All Installed Apps": "",
    "Enable USB Debugging via ADB": "adb shell settings put global adb_enabled 1",
    "Disable Lock Screen (root)": "adb shell su -c 'rm /data/system/gesture.key'",
    "Bypass FRP Lock (root)": "adb shell su -c 'rm -rf /data/system/users/0/*'",
    "Reboot Device": "adb reboot",
    "Reboot to Recovery": "adb reboot recovery",
    "Reboot to Bootloader": "adb reboot bootloader",
    "Simulate Tap at (X, Y)": "adb shell input tap 500 1000",
    "Simulate Swipe Right": "adb shell input swipe 600 500 300 500 300",
    "Simulate Swipe Left": "adb shell input swipe 300 500 600 500 300",  
    "Simulate Swipe Down": "adb shell input swipe 400 700 400 300 300",  
    "Simulate Swipe Up": "adb shell input swipe 400 300 400 700 300", 
    "Simulate Typing": "adb shell input text 'HelloWorld'",
    "Simulate Key Press (Enter)": "adb shell input keyevent 66",
    "Simulate Key Press (Back)": "adb shell input keyevent 4",
    "Unlock Screen (root)": "adb shell su -c 'input keyevent 26 && input swipe 300 1000 300 500'",
    "Lock Screen (root)": "adb shell su -c 'input keyevent 26'",
    "Increase Volume": "adb shell input keyevent 24",
    "Decrease Volume": "adb shell input keyevent 25",
    "Mute Device": "adb shell input keyevent 164",
    "Take a Screenshot": "adb shell screencap -p /sdcard/screenshot.png && adb pull /sdcard/screenshot.png",
    "Start Screen Recording": "adb shell screenrecord /sdcard/record.mp4 && adb pull /sdcard/record.mp4",
    "Play Audio File": "adb shell am start -a android.intent.action.VIEW -d file:///sdcard/song.mp3 -t audio/mp3",
    "Show System Properties": "adb shell getprop",
    "Check SELinux Status": "adb shell getenforce",
    "Set SELinux to Permissive (root)": "adb shell su -c 'setenforce 0'",
    "Set SELinux to Enforcing (root)": "adb shell su -c 'setenforce 1'",
    "Show Boot Logs": "adb shell dmesg",
    "Show System Events": "adb shell logcat -b events",
    "Show Power Stats": "adb shell dumpsys batterystats",
    "Open Image": "",
    "View Image": "",
    "Send SMS": "",
    "Dump File System (root)": "get_fs",
    "Dump Memory (root)": "get_mem",
    "Dump Network Traffic (root)": "get_net",
    "Control Device Screen": "",
    "Extract WhatsApp Messages (root)": "adb shell su -c 'cp /data/data/com.whatsapp/databases/msgstore.db /sdcard/' && adb pull /sdcard/msgstore.db",
    "Extract WhatsApp Calls (root)": "adb shell su -c 'cp /data/data/com.whatsapp/databases/call_log.db /sdcard/' && adb pull /sdcard/call_log.db",
    "Extract WhatsApp Contacts (root)": "adb shell su -c 'cp /data/data/com.whatsapp/databases/wa.db /sdcard/' && adb pull /sdcard/wa.db",
    "Extract Telegram Messages (root)": "adb shell su -c 'cp /data/data/org.telegram.messenger/databases/cache4.db /sdcard/' && adb pull /sdcard/cache4.db",
    "Extract Telegram Contacts (root)": "adb shell su -c 'cp /data/data/org.telegram.messenger/databases/user.db /sdcard/' && adb pull /sdcard/user.db",
    "Extract Facebook Messenger Messages (root)": "adb shell su -c 'cp /data/data/com.facebook.orca/databases/threads_db2 /sdcard/' && adb pull /sdcard/threads_db2",
    "Extract Facebook Cookies & Tokens (root)": "adb shell su -c 'cp /data/data/com.facebook.katana/app_webview/Cookies /sdcard/' && adb pull /sdcard/Cookies",
    "Extract Instagram DM Messages (root)": "adb shell su -c 'cp /data/data/com.instagram.android/databases/direct.db /sdcard/' && adb pull /sdcard/direct.db",
    "Extract Instagram Login Data (root)": "adb shell su -c 'cp /data/data/com.instagram.android/databases/accounts.db /sdcard/' && adb pull /sdcard/accounts.db",
    "Extract Snapchat Messages (root)": "adb shell su -c 'cp /data/data/com.snapchat.android/databases/messages.db /sdcard/' && adb pull /sdcard/messages.db",
    "Extract Snapchat Stories (root)": "adb shell su -c 'cp /data/data/com.snapchat.android/databases/stories.db /sdcard/' && adb pull /sdcard/stories.db",
    "Extract Twitter Messages (root)": "adb shell su -c 'cp /data/data/com.twitter.android/databases/dm.db /sdcard/' && adb pull /sdcard/dm.db",
    "Extract Twitter Login Data (root)": "adb shell su -c 'cp /data/data/com.twitter.android/databases/account.db /sdcard/' && adb pull /sdcard/account.db",
    "Extract TikTok Messages (root)": "adb shell su -c 'cp /data/data/com.zhiliaoapp.musically/databases/message.db /sdcard/' && adb pull /sdcard/message.db",
    "Extract TikTok Watch History (root)": "adb shell su -c 'cp /data/data/com.zhiliaoapp.musically/databases/feed.db /sdcard/' && adb pull /sdcard/feed.db",
    "Extract YouTube Watch History (root)": "adb shell su -c 'cp /data/data/com.google.android.youtube/databases/watch_history.db /sdcard/' && adb pull /sdcard/watch_history.db",
    "Extract YouTube Comments (root)": "adb shell su -c 'cp /data/data/com.google.android.youtube/databases/comments.db /sdcard/' && adb pull /sdcard/comments.db",
    "Extract Chrome Saved Passwords (root)": "adb shell su -c 'cp /data/data/com.android.chrome/app_chrome/Default/Login Data /sdcard/' && adb pull /sdcard/Login Data",
    "Extract Chrome Cookies (root)": "adb shell su -c 'cp /data/data/com.android.chrome/app_chrome/Default/Cookies /sdcard/' && adb pull /sdcard/Cookies",
    "Extract Chrome History (root)": "adb shell su -c 'cp /data/data/com.android.chrome/app_chrome/Default/History /sdcard/' && adb pull /sdcard/History",
    "Extract Google Maps Location History (root)": "adb shell su -c 'cp /data/data/com.google.android.apps.maps/databases/DaDestinationHistory.db /sdcard/' && adb pull /sdcard/DaDestinationHistory.db",
    "Extract Google Maps Saved Places (root)": "adb shell su -c 'cp /data/data/com.google.android.apps.maps/databases/places.db /sdcard/' && adb pull /sdcard/places.db",
    "Extract Signal Messages (root)": "adb shell su -c 'cp /data/data/org.thoughtcrime.securesms/databases/messages.db /sdcard/' && adb pull /sdcard/messages.db",
    "Extract Signal Contacts (root)": "adb shell su -c 'cp /data/data/org.thoughtcrime.securesms/databases/contacts.db /sdcard/' && adb pull /sdcard/contacts.db",
    "Extract Discord Messages (root)": "adb shell su -c 'cp /data/data/com.discord/databases/messages_db /sdcard/' && adb pull /sdcard/messages_db",
    "Extract Discord Login Tokens (root)": "adb shell su -c 'cp /data/data/com.discord/shared_prefs/discord_preferences.xml /sdcard/' && adb pull /sdcard/discord_preferences.xml",
    "Extract PayPal Database (root)": "adb shell su -c 'cp /data/data/com.paypal.android.p2pmobile/databases/transactions.db /sdcard/' && adb pull /sdcard/transactions.db",
    "Extract Google Pay Transactions (root)": "adb shell su -c 'cp /data/data/com.google.android.apps.walletnfcrel/databases/wallet.db /sdcard/' && adb pull /sdcard/wallet.db",
})

def how_to():
    howto = f'''
    {GREEN}How to enable ADB debugging{RESET}:
    1. Open Settings
    2. Tap on "Developer options"
    3. Tap on "USB debugging"
    4. Tap on "Allow USB debugging"
    
    {GREEN}First time setup [how to enabe Developer options]{RESET}:
    1. Open Settings
    2. Tap on "About Phone"
    3. Tap on "Build Number" 7 Times
    '''
    table_data = [[line] for line in howto.strip().split("\n")]
    formatted_output = tabulate(table_data, tablefmt="grid")
    print("\n" + '\n'.join(['\t ' + line for line in formatted_output.split('\n')]))

def check_adb():
    try:
        subprocess.run(["adb", "version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    except FileNotFoundError:
        print(f"\n\t {red_warning} {RED} ADB is not installed. Please install it and try again.{RESET}\n")
        sys.exit(1)

def is_device_rooted():
    result = subprocess.run("adb shell getprop ro.secure", shell=True, capture_output=True, text=True)
    if result.stdout.strip() == "0":
        return True 
    else:
        return False
    
def check_device():
    while True:
        try:
            banner()
            result = subprocess.run(["adb", "devices"], capture_output=True, text=True, check=True)
            if "device" not in result.stdout.split("\n")[1]:
                print(f"\n\t {red_warning}{RED} No device connected. Ensure USB debugging is enabled.{RESET}\n")
                print(f'\t {green_command} Connect your device now.')
                how_to()
                time.sleep(1)
                continue
            else:
                global current_device, current_name, current_version
                current_device = subprocess.run(["adb", "shell", "getprop", "ro.product.model"], capture_output=True, text=True, check=True)
                current_name = subprocess.run(["adb", "shell", "getprop", "ro.product.manufacturer"], capture_output=True, text=True, check=True)
                current_version = subprocess.run(["adb", "shell", "getprop", "ro.build.version.release"], capture_output=True, text=True, check=True)
                print(f"\n\t {green_command} Device [{GREEN}{current_device.stdout.strip()}{RESET}] connected.")
                time.sleep(2)
                break
        except subprocess.CalledProcessError:
            print(f"\t {RED} Error while checking device connection.{RESET}")
            sys.exit(1)
        except KeyboardInterrupt:
            sys.exit(1)

def run_adb_command(command, command_name):
    try:
        if command_name == 'Dump File System (root)':
            subprocess.run("adb shell su -c 'tar -cvf /sdcard/full_dump.tar /data/'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb pull /sdcard/full_dump.tar", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"\n\t {green_command} File System Dump Completed!")
            
        elif command_name == 'Dump Memory (root)':
            subprocess.run("adb push lime.ko /data/local/tmp/'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb shell su -c 'insmod /data/local/tmp/lime.ko path=/sdcard/memdump format=raw'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb pull /sdcard/memdump", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"\n\t {green_command} Memory Dump Completed!")

        elif command_name == 'Dump Network Traffic (root)':
            os.system('wget https://www.androidtcpdump.com/download/4.99.5.1.10.5/tcpdump 2>&! /dev/null')
            subprocess.run("adb push tcpdump /sdcard", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb shell su -c 'chmod 777 /sdcard/tcpdump'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb shell su -c '/sdcard/tcpdump -i any -w /sdcard/network.pcap'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.run("adb pull /sdcard/network.pcap", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"\n\t {green_command} Network Traffic Capture Completed!")

        elif command_name == 'Get Shell':
            print(f'\n\t {green_command} type "exit" to exit ADB Shell.\n')
            subprocess.run("adb shell", shell=True)

        elif command_name == "Find Specific File":
            search = input(f"\n\t {green_question} Enter search term: ").strip()
            result = subprocess.run(f"adb shell find /sdcard/ -name '{search}' 2>&1 | grep -v 'Permission denied'", shell=True, text=True, capture_output=True, check=True)
            print('\n' + '\n'.join(['\t ' + line for line in tabulate([[result.stdout.strip()]], tablefmt='grid').split('\n')]) + '\n')

        elif command_name == "View Image":
            image_path = input(f"\n\t {green_question} Enter image path: ").strip()
            actual_path = image_path.split("/")[-1]
            subprocess.run(f"adb pull {image_path}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.Popen(f"nohup feh {actual_path}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
        elif command_name == "Open Image":
            image_path = input(f"\n\t {green_question} Enter local image path: ").strip()
            subprocess.run(f"adb push {image_path} /sdcard/IMG.png", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.Popen(f"adb shell am start -a android.intent.action.VIEW -d file:///sdcard/IMG.png -t image/png", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
        elif command_name == 'Play Audio File':
            audio_path = input(f"\n\t {green_question} Enter local audio path: ").strip()
            subprocess.run(f"adb push {audio_path} /sdcard/audio.mp3", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            subprocess.Popen(f"adb shell am start -a android.intent.action.VIEW -d file:///sdcard/audio.mp3 -t audio/mp3", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        elif command_name == 'Simulate Typing':
            while True:
                text = input(f"\n\t {green_question} Enter TEXT or q to quit: ").strip()
                if text == 'q':
                    break
                subprocess.run(f'adb shell input text "{text.replace(" ", "%s")}"', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        elif command_name == 'Send SMS':
            number = input(f"\n\t {green_question} Enter number: ").strip()
            message = input(f"\n\t {green_question} Enter message: ").strip()
            if number and message:        
                subprocess.run(f"adb shell am start -a android.intent.action.SENDTO -d sms:{number} -e sms_body '{message}'", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            else:
                print(f"\n\t {red_warning} Invalid number or message.")
                
        elif command_name == 'List All Installed Apps':
            select = input(f"\n\t {green_question} Enter '1' {GREEN}Installed apps{RESET} '2' {GREEN}System apps{RESET} '3' Search Specific App: ").strip()
            if select == '1':
                result = subprocess.run("adb shell pm list packages -3 --user 0", shell=True, capture_output=True, text=True)
            elif select == '2':
                result = subprocess.run("adb shell pm list packages --user 0", shell=True, capture_output=True, text=True)
            elif select == '3':
                app_name = input(f"\n\t {green_question} Enter app name: ").strip()
                if not app_name:
                    print(f"\n\t {red_warning}{RED} Please enter a valid app name.{RESET}")
                    return
                result = subprocess.run(f"adb shell pm list packages -3 --user 0 | grep {app_name}", shell=True, capture_output=True, text=True)
            else:
                print(f"\n\t {red_warning} Invalid selection.")
                return
            
            if result.stdout.strip():
                output_lines = [line.replace("package:", "").strip() for line in result.stdout.strip().split("\n")]
                output_text = "\n".join(output_lines)
                formatted_output = tabulate([[output_text]], tablefmt="grid")
                print("\n" + '\n'.join(['\t ' + line for line in formatted_output.split('\n')]))
            else:
                print(f"\n\t {red_warning} No packages found.")
                
        elif command_name == 'List All Permissions of an App':
            app_name = input(f"\n\t {green_question} Enter app name: ").strip()
            if not app_name:
                print(f"\n\t {red_warning}{RED} Please enter a valid app name.{RESET}")
                return
            
            result = subprocess.run(f"adb shell dumpsys package {app_name} | grep permission", shell=True, capture_output=True, text=True)
            if result.stdout.strip():
                output_lines = [line.replace("permission:", "").strip() for line in result.stdout.strip().split("\n")]
                output_text = "\n".join(output_lines)
                formatted_output = tabulate([[output_text]], tablefmt="grid")
                print("\n" + '\n'.join(['\t ' + line for line in formatted_output.split('\n')]))
            else:
                print("\n\t No permissions found.") 
                   
        elif command_name == 'Get APK File of an Installed App':
            app_name = input(f"\n\t {green_question} Enter app package name: ").strip()

            if not app_name:
                print(f"\n\t {red_warning}{RED} Please enter a valid package name.{RESET}")
                exit()

            result = subprocess.run( f"adb shell pm path {app_name}", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            if result.returncode != 0 or not result.stdout.strip():
                print(f"\n\t {red_warning}{RED} Error: Failed to find APK for '{app_name}'.{RESET}")
                print(f"\n\t Debug Info: {result.stderr.strip() or 'Unknown error'}")
                exit()

            apk_paths = [line.replace("package:", "").strip() for line in result.stdout.strip().split("\n")]

            for apk_path in apk_paths:
                pull_command = f"adb pull {apk_path}"
                pull_result = subprocess.run(pull_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                if pull_result.returncode != 0:
                    print(f"\n\t {red_warning}{RED} Error downloading: {apk_path} {RESET}")
                    print(f"\n\t Debug Info: {pull_result.stderr.strip() or 'Unknown error'}")
                else:
                    print(f"\n\t {green_command} Downloaded: {apk_path}")

            if apk_paths:
                formatted_output = tabulate([[path] for path in apk_paths], headers=[f"{GREEN}Extracted APK Path{RESET}"], tablefmt="grid")
                print("\n" + '\n'.join(['\t ' + line for line in formatted_output.split('\n')]))
                print(f"\n\t {green_command} All APK(s) successfully downloaded!")    
                
        elif command_name in ('Hide an App (root)', 'Unhide Hidden Apps (root)'):
            app_name = input(f"\n\t {green_question} Enter app name: ").strip()
            if not app_name:
                print(f"\n\t {red_warning}{RED} Please enter a valid app name.{RESET}")
                return
            
            if command_name == 'Hide an App (root)':
                subprocess.run(f"adb root", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(f"adb shell pm hide {app_name}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(f"adb unroot", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"\n\t {green_command} App {app_name} hidden.")
            elif command_name == 'Unhide Hidden Apps (root)':
                subprocess.run(f"adb root", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(f"adb shell pm unhide {app_name}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                subprocess.run(f"adb unroot", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"\n\t {green_command} App {app_name} unhidden.")
            else:
                print(f"\n\t {red_warning}{RED} Please enter a valid command.{RESET}")
                return 

        elif command_name in ('Copy a File', 'Upload a File', 'Download a File', 'Delete a File'):
            source_file = None
            destination_file = None

            if command_name == 'Copy a File':
                source_file = input(f"\n\t {green_question} Enter source file path: ").strip()
                destination_file = input(f"\n\t {green_question} Enter destination file path: ").strip()

            elif command_name == 'Upload a File':
                source_file = input(f"\n\t {green_question} Enter local source file path: ").strip()
                destination_file = input(f"\n\t {green_question} Enter destination file path [/sdcard/]: ").strip()

            elif command_name == 'Download a File':
                source_file = input(f"\n\t {green_question} Enter source file path [/sdcard/Picture/image.jpg]: ").strip()
                destination_file = source_file.split("/")[-1]

            elif command_name == 'Delete a File':
                source_file = input(f"\n\t {green_question} Enter source file path [/sdcard/Picture/image.jpg]: ").strip()

            else:
                print(f"\n\t {red_warning}{RED} Please enter a valid command.{RESET}")
                return

            if not source_file:
                print(f"\n\t {red_warning}{RED} Please enter a valid source file path.{RESET}")
                return

            if command_name != 'Delete a File' and not destination_file:
                print(f"\n\t {red_warning}{RED} Please enter a valid destination file path.{RESET}")
                return

            if command_name == 'Copy a File':
                command = f"adb shell cp {source_file} {destination_file}"
            elif command_name == 'Upload a File':
                command = f"adb push {source_file} {destination_file}"
            elif command_name == 'Download a File':
                command = f"adb pull {source_file} {destination_file}"
            elif command_name == 'Delete a File':
                command = f"adb shell rm -f {source_file}"
            else:
                print(f"\n\t {red_warning}{RED} Please enter a valid command.{RESET}")
                return

            print(f"\n\t {green_command}{CYAN} Executing: {command}{RESET}")
            result = subprocess.run(command, shell=True, capture_output=True, text=True)

            if result.returncode == 0:
                if command_name == 'Copy a File':
                    print(f"\n\t {green_command} File successfully copied to {destination_file}.")
                elif command_name == 'Upload a File':
                    print(f"\n\t {green_command} File successfully uploaded to {destination_file}.")
                elif command_name == 'Download a File':
                    print(f"\n\t {green_command} File successfully downloaded to {destination_file}.")
                elif command_name == 'Delete a File':
                    print(f"\n\t {green_command} File successfully deleted.")
            else:
                print(f"\n\t {red_warning}{RED} Error executing {command_name}.{RESET}")

        elif command_name in ('Freeze an App (Disables it)', 'Unfreeze an App (Re-enables it)'):
            app_name = input(f"\n\t {green_question} Enter app name: ").strip()
            if not app_name:
                print(f"\n\t {red_warning}{RED} Please enter a valid app name.{RESET}")
                return
            
            if command_name == 'Freeze an App (Disables it)':
                subprocess.run(f"adb shell pm disable-user --user 0 {app_name}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"\n\t {green_command} App {app_name} frozen.")
            elif command_name == 'Unfreeze an App (Re-enables it)':
                subprocess.run(f"adb shell pm enable {app_name}", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                print(f"\n\t {green_command} App {app_name} unfrozen.")
            else:
                print(f"\n\t {red_warning}{RED} Please enter a valid command.{RESET}")
                return  
        elif command_name == 'Extract App Data (root)':
            app_name = input(f"\n\t {green_question} Enter the app package name: ").strip()

            if not app_name:
                print(f"\n\t {red_warning} Please enter a valid package name.")
                return

            copy_command = f"adb shell su -c 'cp -r /data/data/{app_name} /sdcard/{app_name}/'"
            result = subprocess.run(copy_command, shell=True, capture_output=True, text=True)

            if result.returncode != 0:
                print(f"\n\t {red_warning} Error copying app data: {result.stderr.strip() or 'Unknown error'}")
                return

            pull_result = subprocess.run(f"adb pull /sdcard/{app_name}/ ", shell=True, capture_output=True, text=True)

            if pull_result.returncode != 0:
                print(f"\n\t {red_warning} Error downloading app data: {pull_result.stderr.strip() or 'Unknown error'}")
                return
            
            subprocess.run(f"adb shell rm -rf /sdcard/{app_name}/", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"\n\t {green_command} App {app_name} data successfully downloaded.")
    
        elif command_name == 'Control Device Screen':
            subprocess.Popen(f"nohup scrcpy", shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)    
            print(f"\n\t {green_command} Screen control started.")
        else:
            print(f"\n\t {green_command}{CYAN} Executing: {command}{RESET}")
            result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
            if result.stdout.strip():
                output_text = "\n".join(line.strip() for line in result.stdout.strip().split("\n"))
                formatted_output = tabulate([[output_text]], tablefmt="grid") 
                print("\n" + '\n'.join(['\t ' + line for line in formatted_output.split('\n')]))
            else:
                print(f"\n\t {red_warning}{RED} No output returned.{RESET}")

    except subprocess.CalledProcessError as e:
        print(f"\n\t {red_warning}{RED} Error: {e}{RESET}")
    except subprocess.CalledProcessError as e:
        print(f"\n\t {red_warning}{RED} Command failed:{RESET} {e.stderr.strip()}")
    except Exception as e:
        print(f"\n\t {red_warning}{RED} Unexpected error:{RESET} {e}")

def display_menu(commands):
    def highlight_root(command):
        color = GREEN if rootstatus.lower() == "yes" else RED
        return command.replace("root", f"{color}root{RESET}")

    command_list = list(commands.keys())
    num_commands = len(command_list)
    columns = 4
    rows = (num_commands // columns) + (1 if num_commands % columns else 0)

    table_data = []
    for i in range(rows):
        row = []
        for j in range(columns):
            index = i + j * rows
            if index < num_commands:
                command_text = f"{index+1}. {highlight_root(command_list[index])}"
                row.append(command_text)
            else:
                row.append("")
        table_data.append(row)

    formatted_output = tabulate(table_data, tablefmt="grid")
    return "\n".join(["\t " + line for line in formatted_output.split("\n")])

def main():
    check_adb()
    check_device()
    global rootstatus
    if is_device_rooted():
        rootstatus = f"YES"
    else:
        rootstatus = f"NOT"
    while True:
        banner()
        print(f'\n\t {green_command} DEVICE: {GREEN}{current_device.stdout.strip()}{RESET}')
        print(f'\t {green_command} MANUFACTURER: {GREEN}{current_name.stdout.strip().upper()}{RESET}')
        print(f'\t {green_command} ANDROID VERSION: {GREEN}{current_version.stdout.strip()}{RESET}')
        print(f'\t {green_command} ROOTED: {(GREEN if rootstatus == "YES" else RED) + rootstatus + RESET}')

        print(f"\n\t {green_dot}{GREEN} ADB COMMANDS:{RESET}\n")
        print(display_menu(ADB_COMMANDS))
        try:
            select = input(f"\n\t {green_question} COMMAND [q to quit]: ").strip()
            if select.lower() == 'q':
                print(f"\n\t {red_dot} Exiting...\n\n")
                break
            try:
                cmd_index = int(select) - 1
                command_name = list(ADB_COMMANDS.keys())[cmd_index]
                
                if "(root)" in command_name.lower() and rootstatus.lower() == 'not':
                    print(f"\n\t {red_warning}{RED} This command requires root access.{RESET}")
                    time.sleep(2)
                    continue

                run_adb_command(ADB_COMMANDS[command_name], command_name)
                input(f"\n\t {green_command} Press Enter to continue...")
            
            except (IndexError, ValueError):
                print(f"\n\t {red_warning}{RED} Invalid selection.{RESET}")
                time.sleep(1)
        
        except KeyboardInterrupt:
            sys.exit(1)

if __name__ == "__main__":
    main()

        
    
